---
title: "math 1MP term projects"
date: "`r format(Sys.time(), '%H:%M %d %B %Y')`"
author: Ben Bolker
---

```{r opts,message=FALSE,echo=FALSE,warning=FALSE}
library("knitr")
opts_chunk$set(tidy=FALSE,engine='python',engine.path='python3')
```

These projects are **individual** projects; if you discuss anything about them with other students in the class, you should follow the standard rules (don't write anything down while you are engaged with the other students).  If you get anything from the web, give references.

### Packing simulation

Consider the following stochastic process:

- start with an empty (1D) array of length `n` (i.e. filled with 0)
- as long as possible (see below),
    - check to see if any of the empty elements can be filled (see below)
    - pick a random empty (0) element of the array
	- *if* there is no filled (1) element within radius `r` of the chosen element, fill it. For example, if `r`=1 then the elements immediately to the left and right need to be empty; if `r`=2 then two elements on each side should be empty (boundaries count as empty, e.g. if you pick element 0 of the array then you only need to consider elements from 1 to `r`)
	- otherwise try again
- return the fraction of the array that is full

Write the following functions:

- `fillable(i,a,r=1)`: returns a Boolean that says whether element `i` of array `a` can be filled (i.e. whether `i` and all elements within distance `r` are empty). Make sure to account for boundaries!
- `any_fillable(a,r=1)`: returns a Boolean that says whether any elements of array `a` can be filled
- `fill_one(a,r=1)`: fills a single element of `a` by picking random empty elements *until* it finds one that can be filled.  Returns `None` (modifies the array `a`).  `fill_one()` can assume that `any_fillable()` is `True`.
- `fill_sim(n,r=1)`: creates an array of length `n` and fills it until there are no fillable spaces left; returns the filled array
- `count_sim(n,r=1)`: calls `fill_sim` and computes the proportion of filled spaces in the resulting array
Create a 2-dimensional array with 10 rows and 20 columns. Fill it with the results of `fill_sim()` for radii from 1 to 10 and array sizes from 15 to 49. Create a plot that displays the contents of the array (probably using `matplotlib.pyplot.plot()`).

Submit your code in the drobox as `macid_proj_fill.py` and your plot as `macid_proj_fill.png`


### Chain binomial epidemic models

The *chain binomial* model is a simple epidemic model that says, if there are $S$ susceptible and $I_0$ infected individuals in a well-mixed population (such as a household), that the number of infections in the next infection generation will be $I \sim \textrm{Binomial}\left(S,1-(1-p)^{I_0}\right)$ - a binomial deviate with a probability corresponding each susceptible being infected by at least one of the infected individuals with probability $p$.  In the next generation there will be $S-I$ susceptible individuals and $I$ infected individuals.

- `rbinom(N,prob)`: pick a binomial deviate with `N` trials, each trial having probability `p`. (Pick `N` Uniform(0,1) deviates and count the number that are `<p`; you can use a `for` loop or `numpy` array functions.)
- `cb_gen(S,I0,prob)`: run one generation of the chain binomial model, starting with `S` susceptible and `I0` infected individuals, with a per-infected-per-susceptible infection probability of `prob`. Return a tuple `(new_S,new_I)`
- `cb_sim(S0,I0,prob,nmax)`: run a chain binomial simulation for a maximum of `nmax` steps, starting with `S0` susceptibles and `I0` infected, with a per-individual infection probability `prob`.  Make sure your code doesn't break when the epidemic ends (i.e. there are no new infections). Return a **tuple** that gives the number of infected individuals in each disease generation before the epidemic ends: for example, if you start with `I0`=1 infected in the first step, have 2 infected in the step, then 1 infected, then none, you should return `(1,2,1)`.
- `update_cb_dict(d,k)`: if the epidemic outcome (`k`) is a key in the dictionary, add one to the value associated with the outcome; if not, initialize the dictionary entry to zero

- Run 10,000 simulations of a chain binomial epidemic with `S0=5`, `I0=1`, `prob=0.4`, `nmax=10`;
    - Print the *most likely* epidemic outcome and its probability. The best way to do this is probably to set up an empty dictionary; fill it by running `update_cb_dict()` for each simulated epidemic; and iterate through the dictionary looking for the maximum key value.  Don't forget to divide counts by the number of simulations ...
- Run 10,000 simulations each of the chain binomial epidemic with `S0=5`, `I0=1`, `nmax=10`, and probabilities ranging from 0 to 1 in steps of 0.05. For each infection probability, compute the *mean* number infected (i.e. the mean of the results of `cb_tot()`). Plot the mean as a function of infection probability.

Submit your code in the drobox as `macid_proj_cb.py` and your plot as `macid_proj_cb.png`

### Percolation

(**to be completed**: This problem is harder than the others.)

Many problems in materials science and applied physics depend on the phenomenon of *percolation*, the question of when there will be a connected path of some kind through a material. A simple set of rules for top-bottom percolation will be that if one can traverse a numeric array containing 0 and 1 values ...

Write the following simulation functions:

```{r percolation}
def check_topbottom_path(a,i0,j0):
    """given a 2-dimensional array a (dimensions not explicitly specified)
and a starting position i0,j0, see whether there is a path from there to the bottom"""
    do_some_stuff()  ## incomplete!
```

