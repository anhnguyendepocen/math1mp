---
title: "Week 8: misc. numeric computation"
date: "`r format(Sys.time(), '%H:%M %d %B %Y')`"
author: Ben Bolker
---

```{r opts,message=FALSE,echo=FALSE,warning=FALSE}
library("knitr")
opts_chunk$set(tidy=FALSE,engine="python",engine.path='python3')
```


## Corrections

* Get the shape of an array via `a.shape`, **not** `a.shape()` (shape is an *attribute*, not a *method*, of an array)
* one correct way to check whether an index fits into a list/tuple/string etc. is 
```{r}
def index_ok(i,x):
    n = len(x)
    return(-n <= i < n)
```
* `numpy` arrays have an `order` option: the default `C` gives row-major, `F` (for `FORTRAN`) gives column-major arrays
```{r}
import numpy as np
np.reshape(np.arange(9),(3,3),order="C")
np.reshape(np.arange(9),(3,3),order="F")
```

## Integration

* How should we integrate $\int_0^1 \sqrt{1-x^2} \, dx$?
```{r echo=FALSE}
import matplotlib.pyplot as plt
import numpy as np
x = np.linspace(0,1,101)
y = np.sqrt(1-x**2)
plt.figure(figsize=(4,4))
plt.plot(x,y)
plt.savefig("pix/qtrcirc.png")
```
![quarter circle](pix/qtrcirc.png)

* What about something horrible like $\int_0^1 \exp(-x^2) \log(1+x) \, dx$ ?
* Let's write a couple of programs:
    * brute force (without array functions, only `for` loops)
	* with array functions (we shouldn't need any `for` loops)
* How could we make this better?
    * better integration rules (trapezoid, Simpson's?)
    * choice of `n`
	* adaptive integration (i.e., choice of tolerance): loops within loops ...
* Hard things
    * high dimensions
	* weird shapes/limits of integration

## (Pseudo)random numbers

* From [Wikipedia](http://en.wikipedia.org/wiki/Pseudorandom_number_generator): "Anyone who considers arithmetical methods of producing random digits is, of course, in a state of sin" (von Neumann) ([original paper](https://dornsifecms.usc.edu/assets/sites/520/docs/VonNeumann-ams12p36-38.pdf)) ... "We are here dealing with mere 'cooking recipes' for making digits; probably they can not be justified, but should merely be judged by their results ..."
* *linear congruential generators*:
    * $x_n = (a x_{n-1} + c) \textrm{mod} m$
	* or `x = (a*x +c ) % m`
	* from [here](http://www.eternallyconfuzzled.com/tuts/algorithms/jsw_tut_rand.aspx):
```{r}
x = [5]
(a,c,m) = (2,3,10)
for i in range(9):
    newx = (a*x[-1]+c) % m
    x.append(newx)
print(x)
```
* Park-Miller *minimal standard generator*:
```{r}
import numpy as np
(a,c,m) = (16807,0,2147483647)
x = [5]
for i in range(9):
    newx = (a*x[-1]+c) % m
    x.append(newx)
print(np.array(x)/m)
```

```{r echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt
(a,c,m) = (16807,0,2147483647)
x = [5]
for i in range(1000):
    newx = (a*x[-1]+c) % m
    x.append(newx)
a = np.array(x)/m
plt.figure(figsize=(4,4))
plt.plot(a)
plt.savefig("pix/ran1.png")
```
![random values](pix/ran1.png)

* using `numpy`: [reference](http://docs.scipy.org/doc/numpy/reference/routines.random.html)
```{r}
import numpy.random as rand
a = rand.rand(1000)
```
* can also do useful things like
   * pick from a list: `choice()` (with or without replacement)
   * shuffle values: `shuffle()` (in-place)
   * pick values from different distributions
   * sample from a large range of non-uniform distributions (Poisson, Normal, binomial ...)
* using random number generators for serious work:
   * know what generator is used (Mersenne twister is OK)
   * set the seed: `seed()`
* using random numbers for cryptography: be super-paranoid: see e.g. [this](http://stackoverflow.com/questions/20936993/how-can-i-create-a-random-number-that-is-cryptographically-secure-in-python)

## Monte Carlo integration

* *Monte Carlo* techniques (Ulam)
* Monte Carlo integration
    * pick uniform numbers in a simple region (e.g. square)
	* what fraction fall under the curve?
    * also called *rejection sampling* in this context
* let's write the program
```{r echo=FALSE}
import matplotlib.pyplot as plt
import numpy as np
import numpy.random as rand
rand.seed(101)
x = rand.rand(100)*np.pi
y = rand.rand(100)
plt.figure(figsize=(4,4))
xvec = np.linspace(0,np.pi,101)
yvec = np.sin(xvec)
plt.scatter(x,y)
plt.plot(xvec,yvec)
plt.ylim(0,1)
plt.xlim(0,np.pi)
plt.savefig("pix/mcint.png")
```

![mcint](pix/mcint.png)
## Numeric representations

* Representations of numbers on computers are often inexact
* Integers:
    * arithmetic is exact unless we *overflow* ([xkcd](http://xkcd.com/571/))
	* Python uses *arbitrary-precision* integers (easy but can be slow)
	* underneath, it switches between 4-byte integers (1 *sign bit* + 31 bits of precision) and arbitrary-precision:
```{r}
import sys
print(sys.maxsize)
print(2**31-1)
```
* Floating point ([Wikipedia](http://en.wikipedia.org/wiki/Double-precision_floating-point_format))
    * much harder, trickier
	* stored as *mantissa* and *exponent*
```{r}
import math
(m,e) = math.frexp(1.274e8)	
m*(2**e)
```
```{r}
import sys
sys.float_info
```
8-byte floats=64 bits; mantissa digits (52), sign (1), exponent (11)
    * floating point allows `NaN`, `Inf`, `-Inf`; `math.isnan()`, `math.isinf()`; floating point *overflow*
```{r}
import math
import numpy as np
x = 1e310
print(x)
print(math.isinf(x))
print(1+1e-18==1)
print(0.3-0.1-0.2)
print(0.3-(0.1+0.2))
print(0.3-0.3)
print(format(0.3,".18f"))
np.isclose(0.3,0.1+0.2)
```
* [reference](https://docs.python.org/3.1/tutorial/floatingpoint.html)

* 
* `mpmath`, `gmpy2` modules for arbitrary precision; `decimal` module

## Convolutions (sums of random variables)

* What is the distribution of the *sum* of two (independent) random variables?
* e.g. what is the distribution of the sum of two uniform variables?
* we can do this by integration: the probability (density) that $X+Y=Z$?  It's
$$
\int p(Y=r) \cdot p(X=Z-r) \, dr
$$
This is called a *convolution*, sometimes notated as $p_Z = (p_X * p_Y)$.
* Can sometimes do this analytically.
* Convolve two uniforms:
$$
\int_{\min(r,Z-r)=0}^{\max{r,Z-r}=1} 1 \, dr
$$
or
$$
\left. x \right|_{\min(r,Z-r)=0}^{\max{r,Z-r}=1}
$$
or
$$
\left(r|\max{r,Z-r}=1\right) - \left(r|\min(r,Z-r)=0\right)
$$
* Graphically: area of overlap of two (shifted) curves
```{r engine.path="python",echo=FALSE}
import numpy as np
from matplotlib import pyplot as plt
def f(t):
    return t * t

def u(t,shift=0):
    b = np.logical_and(shift<t,t<(1+shift))
    return(b.astype(float))
    
t = np.arange(0,2,1/40.)
plt.figure(figsize=(4,4))
plt.plot(t,u(t),color="red")
plt.ylim(0,1.25)
plt.xlim(-1,3)
plt.fill_between(t,u(t),facecolor="red",alpha=0.5)
plt.plot(t,u(t,0.75),color="blue")
plt.fill_between(t,u(t,0.75),facecolor="blue",alpha=0.5)
plt.savefig("pix/fill_between.png")
```
![fill](pix/fill_between.png)
* Or we can do it numerically. What should the limits be?
* Write a function to do this integral (`def convolve(px,py,a,b,n)`)?
* Or we can get the distribution by random sampling:
```{r convolve}
import matplotlib.pyplot as plt
import numpy as np
import numpy.random as rand
rand.seed(101)
x = rand.rand(100000)
y = rand.rand(100000)
z = x+y
plt.figure(figsize=(4,4))
plt.hist(z,bins=30)
plt.savefig("pix/hist.png")
```
![sum of uniforms](pix/hist.png)
* multiple convolution??

## Integrating ODEs

* Euler's method
* [midpoint method](http://en.wikipedia.org/wiki/Midpoint_method): 
$$
y_{n+1} = y_n + hf \left(t_n+h/2,y_n+(h/2) f(t_n,y_n) \right)
$$

## The delta method

* to be continued ...
